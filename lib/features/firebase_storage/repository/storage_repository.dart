import 'dart:io';
import 'dart:typed_data';
import 'package:firebase_storage/firebase_storage.dart' as fb_storage;
import '../models/file_info.dart';
import '../models/upload_result.dart';
import '../models/download_result.dart';
import '../errors/storage_error.dart';
import '../utils/storage_config.dart';

/// Repository for Firebase Storage operations
///
/// This is the data layer that wraps Firebase Storage SDK.
/// It handles all direct interactions with Firebase Storage.
class StorageRepository {
  final fb_storage.FirebaseStorage _storage;
  final StorageConfig config;

  StorageRepository({
    fb_storage.FirebaseStorage? firebaseStorage,
    required this.config,
  }) : _storage = firebaseStorage ?? fb_storage.FirebaseStorage.instance;

  /// Get reference to a file
  fb_storage.Reference _getRef(String path, {String? bucket}) {
    final bucketName = bucket ?? config.defaultBucket;
    if (bucketName != null) {
      return _storage.refFromURL('gs://$bucketName/$path');
    }
    return _storage.ref(path);
  }

  /// Validate file before upload
  void _validateFile(String path, int fileSize) {
    // Check file size
    if (config.validateFileSize && !config.isFileSizeAllowed(fileSize)) {
      throw StorageError.fileSizeLimitExceeded(
        fileSize,
        config.maxFileSizeBytes,
      );
    }

    // Check file extension
    if (config.validateExtensions && config.allowedExtensions != null) {
      final extension = path.split('.').last.toLowerCase();
      if (!config.isExtensionAllowed(extension)) {
        throw StorageError.invalidFileExtension(
          extension,
          config.allowedExtensions!,
        );
      }
    }
  }

  /// Upload file from bytes
  Future<UploadResult> uploadBytes({
    required String path,
    required Uint8List data,
    String? bucket,
    UploadOptions? options,
    void Function(int bytesTransferred, int totalBytes)? onProgress,
  }) async {
    final startTime = DateTime.now();

    try {
      _validateFile(path, data.length);

      final ref = _getRef(path, bucket: bucket);
      final uploadOptions = options ?? config.defaultUploadOptions;

      if (config.enableLogging) {
        print('[StorageRepo] Uploading: $path (${data.length} bytes)');
      }

      // Create metadata
      final metadata = fb_storage.SettableMetadata(
        contentType: uploadOptions.contentType,
        cacheControl: uploadOptions.cacheControl,
        contentDisposition: uploadOptions.contentDisposition,
        contentEncoding: uploadOptions.contentEncoding,
        contentLanguage: uploadOptions.contentLanguage,
        customMetadata: uploadOptions.customMetadata,
      );

      // Upload file
      final uploadTask = ref.putData(data, metadata);

      // Listen to progress
      if (onProgress != null) {
        uploadTask.snapshotEvents.listen((snapshot) {
          onProgress(snapshot.bytesTransferred, snapshot.totalBytes);
        });
      }

      // Wait for upload to complete
      final taskSnapshot = await uploadTask;

      // Get metadata and download URL
      final fullMetadata = await taskSnapshot.ref.getMetadata();
      String? downloadUrl;

      if (config.autoGenerateDownloadUrl) {
        try {
          downloadUrl = await taskSnapshot.ref.getDownloadURL();
        } catch (e) {
          if (config.enableLogging) {
            print('[StorageRepo] Could not get download URL: $e');
          }
        }
      }

      final fileInfo = FileInfo.fromMetadata(
        fullMetadata,
        downloadUrl: downloadUrl,
      );

      final duration = DateTime.now().difference(startTime);

      if (config.enableLogging) {
        print('[StorageRepo] Upload successful: $path (${duration.inMilliseconds}ms)');
      }

      return UploadResult.successResult(
        fileInfo: fileInfo,
        downloadUrl: downloadUrl,
        duration: duration,
        bytesTransferred: taskSnapshot.bytesTransferred,
        totalBytes: taskSnapshot.totalBytes,
      );
    } on fb_storage.FirebaseException catch (e, stackTrace) {
      if (config.enableLogging) {
        print('[StorageRepo] Upload failed: ${e.code} - ${e.message}');
      }
      return UploadResult.failure(
        StorageError.fromFirebaseException(
          e,
          bucket: bucket,
          path: path,
          stackTrace: stackTrace,
        ),
      );
    } catch (e, stackTrace) {
      if (e is StorageError) rethrow;
      if (config.enableLogging) {
        print('[StorageRepo] Upload error: $e');
      }
      return UploadResult.failure(
        StorageError.fromException(e, stackTrace, bucket, path),
      );
    }
  }

  /// Upload file from local file path
  Future<UploadResult> uploadFile({
    required String path,
    required File file,
    String? bucket,
    UploadOptions? options,
    void Function(int bytesTransferred, int totalBytes)? onProgress,
  }) async {
    final startTime = DateTime.now();

    try {
      if (!await file.exists()) {
        throw StorageError.objectNotFound(file.path);
      }

      final fileSize = await file.length();
      _validateFile(path, fileSize);

      final ref = _getRef(path, bucket: bucket);
      final uploadOptions = options ?? config.defaultUploadOptions;

      if (config.enableLogging) {
        print('[StorageRepo] Uploading file: ${file.path} -> $path ($fileSize bytes)');
      }

      // Create metadata
      final metadata = fb_storage.SettableMetadata(
        contentType: uploadOptions.contentType,
        cacheControl: uploadOptions.cacheControl,
        contentDisposition: uploadOptions.contentDisposition,
        contentEncoding: uploadOptions.contentEncoding,
        contentLanguage: uploadOptions.contentLanguage,
        customMetadata: uploadOptions.customMetadata,
      );

      // Upload file
      final uploadTask = ref.putFile(file, metadata);

      // Listen to progress
      if (onProgress != null) {
        uploadTask.snapshotEvents.listen((snapshot) {
          onProgress(snapshot.bytesTransferred, snapshot.totalBytes);
        });
      }

      // Wait for upload to complete
      final taskSnapshot = await uploadTask;

      // Get metadata and download URL
      final fullMetadata = await taskSnapshot.ref.getMetadata();
      String? downloadUrl;

      if (config.autoGenerateDownloadUrl) {
        try {
          downloadUrl = await taskSnapshot.ref.getDownloadURL();
        } catch (e) {
          if (config.enableLogging) {
            print('[StorageRepo] Could not get download URL: $e');
          }
        }
      }

      final fileInfo = FileInfo.fromMetadata(
        fullMetadata,
        downloadUrl: downloadUrl,
      );

      final duration = DateTime.now().difference(startTime);

      if (config.enableLogging) {
        print('[StorageRepo] File upload successful: $path (${duration.inMilliseconds}ms)');
      }

      return UploadResult.successResult(
        fileInfo: fileInfo,
        downloadUrl: downloadUrl,
        duration: duration,
        bytesTransferred: taskSnapshot.bytesTransferred,
        totalBytes: taskSnapshot.totalBytes,
      );
    } on fb_storage.FirebaseException catch (e, stackTrace) {
      if (config.enableLogging) {
        print('[StorageRepo] File upload failed: ${e.code} - ${e.message}');
      }
      return UploadResult.failure(
        StorageError.fromFirebaseException(
          e,
          bucket: bucket,
          path: path,
          stackTrace: stackTrace,
        ),
      );
    } catch (e, stackTrace) {
      if (e is StorageError) rethrow;
      if (config.enableLogging) {
        print('[StorageRepo] File upload error: $e');
      }
      return UploadResult.failure(
        StorageError.fromException(e, stackTrace, bucket, path),
      );
    }
  }

  /// Download file to memory
  Future<DownloadResult> downloadBytes({
    required String path,
    String? bucket,
    int? maxSize,
  }) async {
    final startTime = DateTime.now();

    try {
      final ref = _getRef(path, bucket: bucket);

      if (config.enableLogging) {
        print('[StorageRepo] Downloading: $path');
      }

      // Download file
      final data = await ref.getData(maxSize);

      if (data == null) {
        throw StorageError.downloadFailed('No data received');
      }

      // Get metadata
      final metadata = await ref.getMetadata();
      String? downloadUrl;

      try {
        downloadUrl = await ref.getDownloadURL();
      } catch (e) {
        if (config.enableLogging) {
          print('[StorageRepo] Could not get download URL: $e');
        }
      }

      final fileInfo = FileInfo.fromMetadata(metadata, downloadUrl: downloadUrl);
      final duration = DateTime.now().difference(startTime);

      if (config.enableLogging) {
        print('[StorageRepo] Download successful: $path (${data.length} bytes, ${duration.inMilliseconds}ms)');
      }

      return DownloadResult.successResult(
        data: data,
        fileInfo: fileInfo,
        duration: duration,
        bytesTransferred: data.length,
        totalBytes: data.length,
      );
    } on fb_storage.FirebaseException catch (e, stackTrace) {
      if (config.enableLogging) {
        print('[StorageRepo] Download failed: ${e.code} - ${e.message}');
      }
      return DownloadResult.failure(
        StorageError.fromFirebaseException(
          e,
          bucket: bucket,
          path: path,
          stackTrace: stackTrace,
        ),
      );
    } catch (e, stackTrace) {
      if (e is StorageError) rethrow;
      if (config.enableLogging) {
        print('[StorageRepo] Download error: $e');
      }
      return DownloadResult.failure(
        StorageError.fromException(e, stackTrace, bucket, path),
      );
    }
  }

  /// Download file to local file path
  Future<DownloadResult> downloadFile({
    required String path,
    required File destination,
    String? bucket,
  }) async {
    final startTime = DateTime.now();

    try {
      final ref = _getRef(path, bucket: bucket);

      if (config.enableLogging) {
        print('[StorageRepo] Downloading file: $path -> ${destination.path}');
      }

      // Download file
      final downloadTask = ref.writeToFile(destination);
      await downloadTask;

      // Get metadata
      final metadata = await ref.getMetadata();
      String? downloadUrl;

      try {
        downloadUrl = await ref.getDownloadURL();
      } catch (e) {
        if (config.enableLogging) {
          print('[StorageRepo] Could not get download URL: $e');
        }
      }

      final fileInfo = FileInfo.fromMetadata(metadata, downloadUrl: downloadUrl);
      final fileSize = await destination.length();
      final duration = DateTime.now().difference(startTime);

      if (config.enableLogging) {
        print('[StorageRepo] File download successful: $path ($fileSize bytes, ${duration.inMilliseconds}ms)');
      }

      // Read file data for result
      final data = await destination.readAsBytes();

      return DownloadResult.successResult(
        data: data,
        fileInfo: fileInfo,
        duration: duration,
        bytesTransferred: fileSize,
        totalBytes: fileSize,
      );
    } on fb_storage.FirebaseException catch (e, stackTrace) {
      if (config.enableLogging) {
        print('[StorageRepo] File download failed: ${e.code} - ${e.message}');
      }
      return DownloadResult.failure(
        StorageError.fromFirebaseException(
          e,
          bucket: bucket,
          path: path,
          stackTrace: stackTrace,
        ),
      );
    } catch (e, stackTrace) {
      if (e is StorageError) rethrow;
      if (config.enableLogging) {
        print('[StorageRepo] File download error: $e');
      }
      return DownloadResult.failure(
        StorageError.fromException(e, stackTrace, bucket, path),
      );
    }
  }

  /// Delete a file
  Future<void> deleteFile({
    required String path,
    String? bucket,
  }) async {
    try {
      final ref = _getRef(path, bucket: bucket);

      if (config.enableLogging) {
        print('[StorageRepo] Deleting: $path');
      }

      await ref.delete();

      if (config.enableLogging) {
        print('[StorageRepo] Delete successful: $path');
      }
    } on fb_storage.FirebaseException catch (e, stackTrace) {
      if (config.enableLogging) {
        print('[StorageRepo] Delete failed: ${e.code} - ${e.message}');
      }
      throw StorageError.fromFirebaseException(
        e,
        bucket: bucket,
        path: path,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      if (e is StorageError) rethrow;
      if (config.enableLogging) {
        print('[StorageRepo] Delete error: $e');
      }
      throw StorageError.fromException(e, stackTrace, bucket, path);
    }
  }

  /// List files in a directory
  Future<List<FileInfo>> listFiles({
    required String path,
    String? bucket,
    int? maxResults,
  }) async {
    try {
      final ref = _getRef(path, bucket: bucket);

      if (config.enableLogging) {
        print('[StorageRepo] Listing files in: $path');
      }

      final result = await ref.listAll();
      final files = <FileInfo>[];

      for (final item in result.items) {
        try {
          final metadata = await item.getMetadata();
          String? downloadUrl;

          try {
            downloadUrl = await item.getDownloadURL();
          } catch (_) {
            // Ignore if download URL is not available
          }

          files.add(FileInfo.fromMetadata(metadata, downloadUrl: downloadUrl));
        } catch (e) {
          if (config.enableLogging) {
            print('[StorageRepo] Could not get metadata for: ${item.fullPath}');
          }
        }
      }

      if (config.enableLogging) {
        print('[StorageRepo] Listed ${files.length} files');
      }

      return files;
    } on fb_storage.FirebaseException catch (e, stackTrace) {
      if (config.enableLogging) {
        print('[StorageRepo] List failed: ${e.code} - ${e.message}');
      }
      throw StorageError.fromFirebaseException(
        e,
        bucket: bucket,
        path: path,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      if (e is StorageError) rethrow;
      if (config.enableLogging) {
        print('[StorageRepo] List error: $e');
      }
      throw StorageError.fromException(e, stackTrace, bucket, path);
    }
  }

  /// Get file metadata
  Future<FileInfo> getMetadata({
    required String path,
    String? bucket,
  }) async {
    try {
      final ref = _getRef(path, bucket: bucket);

      if (config.enableLogging) {
        print('[StorageRepo] Getting metadata for: $path');
      }

      final metadata = await ref.getMetadata();
      String? downloadUrl;

      try {
        downloadUrl = await ref.getDownloadURL();
      } catch (e) {
        if (config.enableLogging) {
          print('[StorageRepo] Could not get download URL: $e');
        }
      }

      return FileInfo.fromMetadata(metadata, downloadUrl: downloadUrl);
    } on fb_storage.FirebaseException catch (e, stackTrace) {
      if (config.enableLogging) {
        print('[StorageRepo] Get metadata failed: ${e.code} - ${e.message}');
      }
      throw StorageError.fromFirebaseException(
        e,
        bucket: bucket,
        path: path,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      if (e is StorageError) rethrow;
      if (config.enableLogging) {
        print('[StorageRepo] Get metadata error: $e');
      }
      throw StorageError.fromException(e, stackTrace, bucket, path);
    }
  }

  /// Get download URL for a file
  Future<String> getDownloadUrl({
    required String path,
    String? bucket,
  }) async {
    try {
      final ref = _getRef(path, bucket: bucket);

      if (config.enableLogging) {
        print('[StorageRepo] Getting download URL for: $path');
      }

      return await ref.getDownloadURL();
    } on fb_storage.FirebaseException catch (e, stackTrace) {
      if (config.enableLogging) {
        print('[StorageRepo] Get download URL failed: ${e.code} - ${e.message}');
      }
      throw StorageError.fromFirebaseException(
        e,
        bucket: bucket,
        path: path,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      if (e is StorageError) rethrow;
      if (config.enableLogging) {
        print('[StorageRepo] Get download URL error: $e');
      }
      throw StorageError.fromException(e, stackTrace, bucket, path);
    }
  }

  /// Update file metadata
  Future<FileInfo> updateMetadata({
    required String path,
    String? bucket,
    fb_storage.SettableMetadata? metadata,
  }) async {
    try {
      final ref = _getRef(path, bucket: bucket);

      if (config.enableLogging) {
        print('[StorageRepo] Updating metadata for: $path');
      }

      final updatedMetadata = await ref.updateMetadata(metadata);
      String? downloadUrl;

      try {
        downloadUrl = await ref.getDownloadURL();
      } catch (e) {
        if (config.enableLogging) {
          print('[StorageRepo] Could not get download URL: $e');
        }
      }

      return FileInfo.fromMetadata(updatedMetadata, downloadUrl: downloadUrl);
    } on fb_storage.FirebaseException catch (e, stackTrace) {
      if (config.enableLogging) {
        print('[StorageRepo] Update metadata failed: ${e.code} - ${e.message}');
      }
      throw StorageError.fromFirebaseException(
        e,
        bucket: bucket,
        path: path,
        stackTrace: stackTrace,
      );
    } catch (e, stackTrace) {
      if (e is StorageError) rethrow;
      if (config.enableLogging) {
        print('[StorageRepo] Update metadata error: $e');
      }
      throw StorageError.fromException(e, stackTrace, bucket, path);
    }
  }
}
